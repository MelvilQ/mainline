<!DOCTYPE html>
<html>
  <head>
    <title>MainLine</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link rel="stylesheet" href="chessboard.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,500,700">
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.js"></script>
    <script src="vue-chessboard.browser.js"></script>
    <script src="axios.min.js"></script>
  </head>
  <body>

    <div id="app">
      <opening-chessboard 
        :fen="position" 
        :orientation="playerColor" 
        :opponent="opponentConfig"
        :event="event" 
        @progress="refreshProgress"
        @opening="refreshOpeningName"
        @move="addMoveToList"
        @mistake="onWrongMove"
        @middlegame="onMiddlegameReached">
      </opening-chessboard>
      <div class="button-line">
        <button @click="emit('undo')">&lt;&lt;</button>
      </div>
      <div id="info">{{openingName}}</div>
      <div>
        <div>
          <span>{{currentPositionPlayed}}</span>
          <span>{{progress}}</span>
        </div>
        <div v-for="move in moves">
          <span>{{move.text}}</span>
          <span>{{formatStrength(move.strength)}}</span>
          <span>{{formatProbability(move.probability)}}</span>
        </div>
      </div>
    </div>

    <script>
const openingChessboard = {
  extends: VueChessboard.chessboard,
  props: ['event', 'opponent'],
  watch: {
    event(event) {
      if (event.type === 'undo') {
        this.undo();
      }
    }
  },
  methods: {
    startPosition() {
      if (this.orientation.startsWith(this.game.turn())) {
        this.preparePlayerMove();
      } else {
        this.prepareOpponentMove();
      }
    },
    async preparePlayerMove() {
      await this.getOpeningInfo();
      if (this.openingInfo.played < 10) {
        this.board.set({turnColor: null, movable: false});
        this.$emit('middlegame');
        return;
      }
      this.board.set({
        turnColor: this.toColor(),
        movable: {
          color: this.toColor(),
          dests: this.possibleMoves(),
          events: {after: this.onMoveInput}
        }
      });
    },
    async getOpeningInfo(database = 'master', queryOptions = {}) {
      if (database === 'lichess') {
        queryOptions.variant = 'standard';
      }
      const response = await axios.get('https://explorer.lichess.ovh/' + database, 
        {params: {fen: this.game.fen(), moves: 20, ...queryOptions}});
      const openingInfo = response.data;
      const sum = openingInfo.white + openingInfo.black + openingInfo.draws;
      this.$emit('progress', sum);
      openingInfo.played = sum;
      openingInfo.isLosing = sum > 0 && ((this.game.turn() === 'w' ? openingInfo.black : openingInfo.white) / sum) > 0.5;
      openingInfo.moves.forEach(m => m.text = m.san.replace('Q','D').replace('R','T').replace('B','L').replace('N','S'));
      openingInfo.moves.forEach(m => m.played = m.white + m.black + m.draws);
      openingInfo.moves.forEach(m => m.probability = (sum > 0) ? m.played / sum : 0);
      openingInfo.moves.forEach(m => m.isLosing = 
        m.played > 0 && ((this.game.turn() === 'w' ? m.black : m.white) / m.played) > 0.5);
      openingInfo.moves.forEach((m, i) => m.strength = 
        ((m.isLosing || m.probability < 0.03) ? 0 // bad
          : (i === 0 || m.probability > 0.3) ? 3  // top
          : (m.probability < 0.15) ? 1            // playable
          : 2));                                  // good
      this.openingInfo = openingInfo;
      console.log(openingInfo.moves.map(m => [m.text, m.probability, m.isLosing, m.strength]));
      const categorization = this.openingInfo.opening;
      if (!!categorization) {
        this.$emit('opening', `${categorization.eco} - ${categorization.name}`);
      }      
    },
    onMoveInput(from, to) {
      const performedMove = this.game.move({from, to});
      const san = performedMove.san;
      const playedMove = this.openingInfo.moves.find(m => m.san === san);
      if (!playedMove || !playedMove.strength) {
        this.game.undo();
        this.board.set({fen: this.game.fen()});
        this.$emit('mistake', playedMove);
        this.preparePlayerMove();
      } else {
        console.log(`${playedMove.text}: ${playedMove.strength} (${Math.round(playedMove.probability*100)}%)`);
        this.$emit('move', playedMove);
        this.prepareOpponentMove();
      }
    },
    async prepareOpponentMove() {
      this.board.set({
        turnColor: this.toColor(),
      })
      await this.getOpeningInfo(this.opponent.database, this.opponent.options);
      if (!this.openingInfo?.moves?.length) {
        console.log('Keine Züge mehr da...');
        return;
      }
      setTimeout(this.performOpponentMove, 500);
    },
    async performOpponentMove() {
      const opponentMove = this.getMoveForOpponent('realistic');
      const movePerformed = this.game.move(opponentMove);
      this.board.set({fen: this.game.fen()});
      this.preparePlayerMove();
    },
    getMoveForOpponent(mode) {
      const moves = this.openingInfo.moves;
      if (mode === 'main') {
        return moves[0].san;
      } else if (mode === 'equal') {
        return moves[Math.floor(Math.random() * moves.length)].san;
      } else if (mode === 'realistic') {
        let countdown = Math.random();
        for (let i = 0; i < moves.length; ++i) {
          const move = moves[i];
          countdown -= move.probability;
          if (countdown <= 0) {
            return move.san;
          }
        }
      }
      return moves[0].san;
    },
    undo() {
      this.game.undo();
      this.game.undo();
      this.board.set({fen: this.game.fen()});
      this.preparePlayerMove();
    }
  },
  created() {
    this.openingInfo = null;
  },
  mounted() {
    this.startPosition();
  }
};

const app = new Vue({
  el: '#app',
  components: {
    'opening-chessboard': openingChessboard,
  },
  data: {
    position: 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1',
    openingName: '',
    playerColor: 'black',
    opponentConfig: {
      database: 'master',
      //config: {ratings: ['1600', '1800'], speeds: ['blitz', 'rapid', 'classical']}
    },
    currentPositionPlayed: 10000000,
    progress: 0,
    event: null,
    moves: [],
    lifes: 3,
  },
  methods: {
    emit(event) {
      this.event = {type: event};
    },
    refreshProgress(played) {
      this.currentPositionPlayed = played;
      this.progress = (this.currentPositionPlayed < 10) ? 7 
        : (8 - Math.log(this.currentPositionPlayed) / Math.log(10));
    },
    refreshOpeningName(name) {
      this.openingName = name;
    },
    addMoveToList(move) {
      this.moves.push(move);
    },
    onWrongMove(move) {
      this.lifes -= 1;
    },
    onMiddlegameReached() {
      alert('Mittelspiel erfolgreich erreicht. Glückwunsch!');
    },
    formatStrength(strength){
      switch(strength){
        case 3: return 'Top';
        case 2: return 'Good';
        case 1: return 'Ok';
        case 0: return 'Bad';
      }
    },
    formatProbability(p) {
      return `${Math.round(100*p)}%`;
    }
  },
  created() {
    
  }
});

    </script>
  </body>
</html>