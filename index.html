<!DOCTYPE html>
<html>
  <head>
    <title>MainLine</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link rel="stylesheet" href="chessboard.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,500,700">
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.js"></script>
    <script src="vue-chessboard.browser.js"></script>
    <script src="axios.min.js"></script>
  </head>
  <body>

    <div id="app">
      <div id="settings" v-if="showSettings">
        <div>
          <div><strong>Settings</strong></div><br>
          <select v-model="settings.startPosition" @input="validateFen">
            <option v-for="option in startPositionOptions" :value="option.value">{{option.label}}</option>
          </select>
          <div><input type="text" v-model="settings.startPosition" @blur="validateFen"></div>
          <div class="validation-error" v-if="showStartPositionValidationError">Invalid FEN</div>
          <div>
            <input type="radio" id="white" v-model="settings.playerColor" value="white"><label for="white">White</label>
            <input type="radio" id="black" v-model="settings.playerColor" value="black"><label for="black">Black</label>
          </div>
          <div style="text-align: right"><button class="ok" @click="applySettings">OK</button></div>
        </div>
      </div>
      <div id="distribution">
        <div class="white" v-if="currentResultsDistribution" :style="{width: 100*currentResultsDistribution.white + '%'}"></div>
        <div class="draw" v-if="currentResultsDistribution" :style="{width: 100*currentResultsDistribution.draw + '%'}"></div>
        <div class="black" v-if="currentResultsDistribution" :style="{width: 100*currentResultsDistribution.black + '%'}"></div>
      </div>
      <div id="evaluation">
        <div class="white" v-if="currentEvaluation !== null" :style="{width: (0.166*currentEvaluation + 50) + '%'}"></div>
        <div class="black" v-if="currentEvaluation !== null" :style="{width: (-0.166*currentEvaluation + 50) + '%'}"></div>
      </div>
      <opening-chessboard ref="chessboard"
        :fen="startPosition" 
        :orientation="playerColor" 
        :opponent="settings.opponent"
        :event="event" 
        @progress="refreshProgress"
        @distribution="refreshDistribution"
        @evaluation="refreshEvaluation"
        @opening="refreshOpeningName"
        @move="addMoveToList"
        @mistake="onWrongMove"
        @hopeless="onHopelessPosition"
        @middlegame="onMiddlegameReached">
      </opening-chessboard>
      <div class="button-line">
        <button @click="undo">&lt;&lt;</button>
        <button @click="newGame">New</button>
        <button @click="openSettings">Settings</button>
        <button @click="openOnLichess">Analyze</button>
      </div>
      <div id="info">{{currentOpeningName}}</div>
      <div>
        <div>
          <span>#Played: {{currentPositionPlayed}}</span>
          <span style="margin: 0 16px"></span>
          <span>Lifes: {{lifes}}</span>
        </div>
        <div id="moves">
          <div v-for="no in moveNoList" class="move-no" 
            :style="{'grid-row': 100-no}">{{no}}.</div>
          <div v-if="!!moves[0] && moves[0].moveColor === 'b'" class="move-placeholder"
            :style="{'grid-row': 100-moves[0].moveNo}">...</div>
          <div v-for="move in moves" 
            :style="{'grid-column': move.moveColor === 'w' ? 2 : 3, 'grid-row': 100-move.moveNo}">
            <span>{{move.text}}</span>
            <span v-if="move.isPlayerMove">{{formatStrength(move.strength)}}</span>
            <span>{{formatProbability(move.probability)}}</span>
          </div>
        </div>
      </div>
    </div>

    <script>
const openingChessboard = {
  extends: VueChessboard.chessboard,
  props: ['event', 'opponent'],
  watch: {
    event(event) {
      if (event.type === 'lichess') {
        window.open('https://lichess.org/analysis?fen=' + this.game.fen(), '_blank');
      } else if (event.type === 'undo') {
        this.undo();
      } else if (event.type === 'new') {
        this.restartPosition();
      }
    }
  },
  methods: {
    restartPosition() {
      this.loadPosition();
      this.startPosition();
    },
    startPosition() {
      if (this.orientation.startsWith(this.game.turn())) {
        this.preparePlayerMove();
      } else {
        this.prepareOpponentMove();
      }
    },
    async preparePlayerMove() {
      await this.getOpeningInfo();
      await this.getEvaluation();
      if (this.openingInfo.moves.every(m => m.strength === 0)) {
        this.board.set({turnColor: null, movable: false});
        this.$emit('hopeless');
        return;
      } else if (this.openingInfo.played < 10) {
        this.board.set({turnColor: null, movable: false});
        this.$emit('middlegame');
        return;
      }
      this.board.set({
        turnColor: this.toColor(),
        movable: {
          color: this.toColor(),
          dests: this.possibleMoves(),
          events: {after: this.onMoveInput}
        }
      });
    },
    async getOpeningInfo(database = 'master', queryOptions = {}) {
      if (database === 'lichess') {
        queryOptions.variant = 'standard';
      }
      const fen = this.game.fen();
      const response = await axios.get('https://explorer.lichess.ovh/' + database, 
        {params: {fen, moves: 20, ...queryOptions}});
      const openingInfo = response.data;
      const sum = openingInfo.white + openingInfo.black + openingInfo.draws;
      this.$emit('progress', sum);
      this.$emit('distribution', {
        white: openingInfo.white / sum,
        draw: openingInfo.draws / sum,
        black: openingInfo.black / sum,
      });
      openingInfo.played = sum;
      openingInfo.isLosing = sum > 0 && ((this.game.turn() === 'w' ? openingInfo.black : openingInfo.white) / sum) > 0.5;
      const moveNumber = this.getMoveNumber();
      openingInfo.moves.forEach(m => m.moveNo = moveNumber);
      const moveColor = this.game.turn();
      openingInfo.moves.forEach(m => m.moveColor = moveColor);
      openingInfo.moves.forEach(m => m.isPlayerMove = this.orientation.startsWith(moveColor));
      openingInfo.moves.forEach(m => m.text = this.getTextForSan(m.san));
      openingInfo.moves.forEach(m => m.played = m.white + m.black + m.draws);
      openingInfo.moves.forEach(m => m.probability = (sum > 0) ? m.played / sum : 0);
      openingInfo.moves.forEach(m => m.isLosing = 
        m.played > 0 && ((moveColor === 'w' ? m.black : m.white) / m.played) > 0.5);
      openingInfo.moves.forEach((m, i) => m.strength = 
        ((m.isLosing || m.probability < 0.03) ? 0 // bad
          : (i === 0) ? 4                         // top
          : (m.probability > 0.2) ? 3             // good
          : (m.probability > 0.1) ? 2             // ok
          : 1));                                  // playable
      openingInfo.moves.forEach(m => m.alternatives = openingInfo.moves);
      this.openingInfo = openingInfo;
      console.log(openingInfo.moves.map(m => [m.text, m.probability, m.isLosing, m.strength]));
      const categorization = this.openingInfo.opening;
      if (!!categorization) {
        this.$emit('opening', `${categorization.eco} - ${categorization.name}`);
      }      
    },
    async getEvaluation() {
      let evaluation = null;
      try {
        const fen = this.fixFenForLichessCloudEvalApi(this.game.fen());
        const response = await axios.get('https://lichess.org/api/cloud-eval', {params: {fen}});
        evaluation = response.data.pvs[0].cp;
      } catch(e) {
        console.warn('error getting evaluation for ' + this.game.fen());
      }
      this.$emit('evaluation', evaluation);
    },
    fixFenForLichessCloudEvalApi(fen) {
      const fenParts = fen.split(' ');
      const enPassantPart = fenParts[3];
      const canEnPassant = this.game.moves({verbose: true}).some(m => m.flags.includes('e'));
      if (enPassantPart === '-' || canEnPassant) {
        return fen;
      }
      fenParts[3] = '-';
      return fenParts.join(' ');
    },
    onMoveInput(from, to) {
      const performedMove = this.game.move({from, to});
      const san = performedMove.san;
      const playedMove = this.openingInfo.moves.find(m => m.san === san)
        || {san, text: this.getTextForSan(san), alternatives: this.openingInfo.moves, strength: 0};
      const strength = playedMove.strength;
      this.setLastMoveHighlightColor(strength);
      if (strength === 0) {
        this.game.undo();
        this.board.set({fen: this.game.fen()});
        this.$emit('mistake', playedMove);
        this.preparePlayerMove();
      } else {
        this.setLastMoveHighlightColor(strength);
        this.$emit('move', playedMove);
        this.prepareOpponentMove();
      }
    },
    async prepareOpponentMove() {
      this.board.set({
        turnColor: this.toColor(),
        premovable: {enabled: false}
      });
      await this.getOpeningInfo(this.opponent.database, this.opponent.options);
      await this.getEvaluation();
      if (!this.openingInfo?.moves?.length) {
        this.$emit('middlegame');
        return;
      }
      setTimeout(this.performOpponentMove, 500);
    },
    async performOpponentMove() {
      const opponentMove = this.getMoveForOpponent('realistic');
      const movePerformed = this.game.move(opponentMove.san);
      this.$emit('move', opponentMove);
      this.setLastMoveHighlightColor(opponentMove.strength);
      this.board.move(movePerformed.from, movePerformed.to);
      this.preparePlayerMove();
    },
    getMoveForOpponent(mode) {
      const moves = this.openingInfo.moves;
      if (mode === 'main') {
        return moves[0];
      } else if (mode === 'equal') {
        return moves[Math.floor(Math.random() * moves.length)];
      } else if (mode === 'realistic') {
        let countdown = Math.random();
        for (let i = 0; i < moves.length; ++i) {
          const move = moves[i];
          countdown -= move.probability;
          if (countdown <= 0) {
            return move;
          }
        }
      }
      return moves[0];
    },
    undo() {
      this.game.undo();
      this.game.undo();
      this.board.set({fen: this.game.fen()});
      this.preparePlayerMove();
    },
    setLastMoveHighlightColor(strength) {
      let color = 'default';
      if (strength === 0) {
        color = 'red';
      } else if (strength === 1) {
        color = 'yellow';
      } else if (strength === 2) {
        color = 'lightgreen'
      } else if (strength === 4) {
        color = 'green';
      }
      document.getElementById('app').className = color === 'default' ? '' : 'last-move-' + color;
    },
    getMoveNumber() {
      return parseInt(this.game.fen().split(' ')[5]);
    },
    getTextForSan(san) {
      return san.replace('Q','D').replace('R','T').replace('B','L').replace('N','S');
    },
  },
  created() {
    this.openingInfo = null;
  },
  mounted() {
    this.startPosition();
  }
};

const app = new Vue({
  el: '#app',
  components: {
    'opening-chessboard': openingChessboard,
  },
  data: {
    settings: {
      startPosition: 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1',
      playerColor: 'white',
      evaluation: {
        database: 'master',
        config: null,
      },
      opponent: {
        database: 'master',
        //config: {ratings: ['1600', '1800'], speeds: ['blitz', 'rapid', 'classical']}
      },
    },
    showSettings: false,
    startPositionOptions: [
      {label: 'Start', value: 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'},
      {label: 'Sicilian', value: 'rnbqkbnr/pp1ppppp/8/2p5/4P3/8/PPPP1PPP/RNBQKBNR w KQkq - 0 2'},
      {label: 'Najdorf', value: 'rnbqkb1r/1p2pppp/p2p1n2/8/3NP3/2N5/PPP2PPP/R1BQKB1R w KQkq - 0 6'},
      {label: 'Dragon', value: 'rnbqkb1r/pp2pp1p/3p1np1/8/3NP3/2N5/PPP2PPP/R1BQKB1R w KQkq - 0 6'},
      {label: 'Accelerated Dragon', value: 'r1bqkbnr/pp1ppp1p/2n3p1/8/3NP3/8/PPP2PPP/RNBQKB1R w KQkq - 0 5'},
      {label: 'Hyperaccelerated Dragon', value: 'rnbqkbnr/pp1ppp1p/6p1/2p5/4P3/5N2/PPPP1PPP/RNBQKB1R w KQkq - 0 3'},
      {label: 'Rossolimo Attack', value: 'r1bqkbnr/pp1ppppp/2n5/1Bp5/4P3/5N2/PPPP1PPP/RNBQK2R b KQkq - 3 3'},
      {label: 'Kalashnikov', value: 'r1bqkbnr/pp1p1ppp/2n5/4p3/3NP3/8/PPP2PPP/RNBQKB1R w KQkq - 0 5'},
      {label: 'Morra-Gambit', value: 'rnbqkbnr/pp1ppppp/8/2p5/3PP3/8/PPP2PPP/RNBQKBNR b KQkq - 0 2'},
      {label: 'Modern Defense', value: 'rnbqkbnr/pppppp1p/6p1/8/4P3/8/PPPP1PPP/RNBQKBNR w KQkq - 0 2'},
      {label: 'Russian', value: 'rnbqkb1r/pppp1ppp/5n2/4p3/4P3/5N2/PPPP1PPP/RNBQKB1R w KQkq - 2 3'},
      {label: 'Queen\'s Gambit Accepted', value: 'rnbqkbnr/ppp1pppp/8/8/2pP4/8/PP2PPPP/RNBQKBNR w KQkq - 0 3'},
      {label: 'Scotch Game', value: 'r1bqkbnr/pppp1ppp/2n5/4p3/3PP3/5N2/PPP2PPP/RNBQKB1R b KQkq - 0 3'},
      {label: 'Italian Game', value: 'r1bqkbnr/pppp1ppp/2n5/4p3/2B1P3/5N2/PPPP1PPP/RNBQK2R b KQkq - 3 3'},
      {label: 'French Defense', value: 'rnbqkbnr/ppp2ppp/4p3/3p4/3PP3/8/PPP2PPP/RNBQKBNR w KQkq - 0 3'},
      {label: 'Scandinavian', value: 'rnbqkbnr/ppp1pppp/8/3p4/4P3/8/PPPP1PPP/RNBQKBNR w KQkq - 0 2'},
      {label: 'Philidor Defense', value: 'rnbqkbnr/ppp2ppp/3p4/4p3/4P3/5N2/PPPP1PPP/RNBQKB1R w KQkq - 0 3'},
    ],
    startPosition: 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1',
    playerColor: 'white',
    showStartPositionValidationError: false,
    currentOpeningName: '',
    currentPositionPlayed: 10000000,
    currentResultsDistribution: null,
    currentEvaluation: null,
    progress: 0,
    event: null,
    moves: [],
    wrongMove: null,
    lifes: 3,
  },
  computed: {
    moveNoList() {
      return [...new Set(this.moves.map(m => m.moveNo))];
    },
  },
  methods: {
    openOnLichess() {
      this.emit('lichess');
    },
    undo() {
      this.emit('undo');
    },
    newGame() {
      this.moves = [];
      this.lifes = 3;
      this.currentOpeningName = '';
      this.currentPositionPlayed = 10000000;
      this.currentResultsDistribution = null;
      this.progress = 0;
      this.emit('new');
    },
    emit(event) {
      this.event = {type: event};
    },
    refreshProgress(played) {
      this.currentPositionPlayed = played;
    },
    refreshDistribution(distribution) {
      this.currentResultsDistribution = distribution;
    },
    refreshEvaluation(evaluation) {
      this.currentEvaluation = evaluation === null ? null : Math.min(300, Math.max(-300, evaluation));
    },
    refreshOpeningName(name) {
      this.currentOpeningName = name;
    },
    addMoveToList(move) {
      this.moves.push(move);
      this.wrongMove = null;
    },
    onWrongMove(move) {
      this.wrongMove = move;
      this.lifes -= 1;
      if (this.lifes <= 0) {
        setTimeout(this.gameOver, 500);
      }
    },
    gameOver() {
      const bestCandidate = this.wrongMove.alternatives.find(m => m.strength > 0)?.text;
      alert('You lost all your lifes. Start again! Best move in this position is ' + bestCandidate + '.');
    },
    onMiddlegameReached() {
      setTimeout(() => alert('Congrats, you made it into the middlegame!'), 500);
    },
    onHopelessPosition() {
      setTimeout(() => alert('This position is hopeless. Try again!'), 500);
    },
    formatStrength(strength) {
      switch(strength) {
        case 4: return 'Top';
        case 3: return 'Good';
        case 2: return 'Ok';
        case 1: return 'Playable';
        case 0: return 'Bad';
      }
    },
    formatProbability(p) {
      return `${Math.round(100*p)}%`;
    },
    openSettings() {
      this.showSettings = true;
    },
    validateFen() {
      this.showStartPositionValidationError = !this.$refs.chessboard.game.validate_fen(this.settings.startPosition).valid;
    },
    applySettings() {
      this.showSettings = false;
      let newGameNeeded = false;
      if (this.showStartPositionValidationError) {
        this.settings.startPosition = this.startPosition;
      } else if (this.settings.startPosition !== this.startPosition) {
        this.startPosition = this.settings.startPosition;
        newGameNeeded = true;
      }
      if (this.settings.playerColor !== this.playerColor) {
        this.playerColor = this.settings.playerColor;
        newGameNeeded = true;
      }
      if (newGameNeeded) {
        this.newGame();
      }
    }
  }
});

    </script>
  </body>
</html>
