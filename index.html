<!DOCTYPE html>
<html>
  <head>
    <title>MainLine</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link rel="stylesheet" href="chessboard.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,500,700">
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.js"></script>
    <script src="vue-chessboard.browser.js"></script>
    <script src="axios.min.js"></script>
  </head>
  <body>

    <div id="app">
      <div id="settings" v-if="showSettings">
        <div>
          <div><strong>Optionen</strong></div><br>
          <select v-model="settings.startPosition" @input="validateFen">
            <option v-for="option in startPositionOptions" :value="option.value">{{option.label}}</option>
          </select>
          <div><input type="text" v-model="settings.startPosition" @blur="validateFen"></div>
          <div class="validation-error" v-if="showStartPositionValidationError">Invalid FEN</div>
          <div>
            <input type="radio" id="white" v-model="settings.playerColor" value="white"><label for="white">White</label>
            <input type="radio" id="black" v-model="settings.playerColor" value="black"><label for="black">Black</label>
          </div>
          <div style="text-align: right"><button class="ok" @click="applySettings">OK</button></div>
        </div>
      </div>
      <opening-chessboard ref="chessboard"
        :fen="startPosition" 
        :orientation="playerColor" 
        :opponent="settings.opponent"
        :event="event" 
        @progress="refreshProgress"
        @opening="refreshOpeningName"
        @move="addMoveToList"
        @mistake="onWrongMove"
        @middlegame="onMiddlegameReached">
      </opening-chessboard>
      <div class="button-line">
        <button @click="emit('undo')">&lt;&lt;</button>
        <button @click="newGame">Neu</button>
        <button @click="openSettings">Optionen</button>
      </div>
      <div id="info">{{currentOpeningName}}</div>
      <div>
        <div>
          <span>{{currentPositionPlayed}}</span>
          <span>{{progress}}</span>
        </div>
        <div v-for="move in moves">
          <span>{{move.text}}</span>
          <span>{{formatStrength(move.strength)}}</span>
          <span>{{formatProbability(move.probability)}}</span>
        </div>
      </div>
    </div>

    <script>
const openingChessboard = {
  extends: VueChessboard.chessboard,
  props: ['event', 'opponent'],
  watch: {
    event(event) {
      if (event.type === 'undo') {
        this.undo();
      } else if (event.type === 'new') {
        this.restartPosition();
      }
    }
  },
  methods: {
    restartPosition() {
      this.loadPosition();
      this.startPosition();
    },
    startPosition() {
      if (this.orientation.startsWith(this.game.turn())) {
        this.preparePlayerMove();
      } else {
        this.prepareOpponentMove();
      }
    },
    async preparePlayerMove() {
      await this.getOpeningInfo();
      if (this.openingInfo.played < 10) {
        this.board.set({turnColor: null, movable: false});
        this.$emit('middlegame');
        return;
      }
      this.board.set({
        turnColor: this.toColor(),
        movable: {
          color: this.toColor(),
          dests: this.possibleMoves(),
          events: {after: this.onMoveInput}
        }
      });
    },
    async getOpeningInfo(database = 'master', queryOptions = {}) {
      if (database === 'lichess') {
        queryOptions.variant = 'standard';
      }
      const response = await axios.get('https://explorer.lichess.ovh/' + database, 
        {params: {fen: this.game.fen(), moves: 20, ...queryOptions}});
      const openingInfo = response.data;
      const sum = openingInfo.white + openingInfo.black + openingInfo.draws;
      this.$emit('progress', sum);
      openingInfo.played = sum;
      openingInfo.isLosing = sum > 0 && ((this.game.turn() === 'w' ? openingInfo.black : openingInfo.white) / sum) > 0.5;
      openingInfo.moves.forEach(m => m.text = m.san.replace('Q','D').replace('R','T').replace('B','L').replace('N','S'));
      openingInfo.moves.forEach(m => m.played = m.white + m.black + m.draws);
      openingInfo.moves.forEach(m => m.probability = (sum > 0) ? m.played / sum : 0);
      openingInfo.moves.forEach(m => m.isLosing = 
        m.played > 0 && ((this.game.turn() === 'w' ? m.black : m.white) / m.played) > 0.5);
      openingInfo.moves.forEach((m, i) => m.strength = 
        ((m.isLosing || m.probability < 0.03) ? 0 // bad
          : (i === 0 || m.probability > 0.3) ? 3  // top
          : (m.probability < 0.15) ? 1            // playable
          : 2));                                  // good
      this.openingInfo = openingInfo;
      console.log(openingInfo.moves.map(m => [m.text, m.probability, m.isLosing, m.strength]));
      const categorization = this.openingInfo.opening;
      if (!!categorization) {
        this.$emit('opening', `${categorization.eco} - ${categorization.name}`);
      }      
    },
    onMoveInput(from, to) {
      const performedMove = this.game.move({from, to});
      const san = performedMove.san;
      const playedMove = this.openingInfo.moves.find(m => m.san === san);
      if (!playedMove || !playedMove.strength) {
        this.setLastMoveHighlightColor('red');
        this.game.undo();
        this.board.set({fen: this.game.fen()});
        this.$emit('mistake', playedMove);
        this.preparePlayerMove();
      } else {
        this.setLastMoveHighlightColor((playedMove.strength < 2) ? 'yellow' : 'default');
        this.$emit('move', playedMove);
        this.prepareOpponentMove();
      }
    },
    async prepareOpponentMove() {
      this.board.set({
        turnColor: this.toColor(),
        premovable: {enabled: false}
      });
      await this.getOpeningInfo(this.opponent.database, this.opponent.options);
      if (!this.openingInfo?.moves?.length) {
        this.$emit('middlegame');
        return;
      }
      setTimeout(this.performOpponentMove, 500);
    },
    async performOpponentMove() {
      const opponentMove = this.getMoveForOpponent('realistic');
      const movePerformed = this.game.move(opponentMove);
      this.setLastMoveHighlightColor((opponentMove.strength < 2) ? 'yellow' : 'default');
      this.board.move(movePerformed.from, movePerformed.to);
      this.preparePlayerMove();
    },
    getMoveForOpponent(mode) {
      const moves = this.openingInfo.moves;
      if (mode === 'main') {
        return moves[0].san;
      } else if (mode === 'equal') {
        return moves[Math.floor(Math.random() * moves.length)].san;
      } else if (mode === 'realistic') {
        let countdown = Math.random();
        for (let i = 0; i < moves.length; ++i) {
          const move = moves[i];
          countdown -= move.probability;
          if (countdown <= 0) {
            return move.san;
          }
        }
      }
      return moves[0].san;
    },
    undo() {
      this.game.undo();
      this.game.undo();
      this.board.set({fen: this.game.fen()});
      this.preparePlayerMove();
    },
    setLastMoveHighlightColor(color) {
      document.getElementById('app').className = color === 'default' ? '' : 'last-move-' + color;
    },
  },
  created() {
    this.openingInfo = null;
  },
  mounted() {
    this.startPosition();
  }
};

const app = new Vue({
  el: '#app',
  components: {
    'opening-chessboard': openingChessboard,
  },
  data: {
    settings: {
      startPosition: 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1',
      playerColor: 'white',
      evaluation: {
        database: 'master',
        config: null,
      },
      opponent: {
        database: 'master',
        //config: {ratings: ['1600', '1800'], speeds: ['blitz', 'rapid', 'classical']}
      },
    },
    showSettings: false,
    startPositionOptions: [
      {label: 'Default', value: 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'},
      {label: 'Najdorf', value: 'rnbqkb1r/1p2pppp/p2p1n2/8/3NP3/2N5/PPP2PPP/R1BQKB1R w KQkq - 0 6'},
      {label: 'Dragon', value: 'rnbqkb1r/pp2pp1p/3p1np1/8/3NP3/2N5/PPP2PPP/R1BQKB1R w KQkq - 0 6'},
      {label: 'Accelerated Dragon', value: 'r1bqkbnr/pp1ppp1p/2n3p1/8/3NP3/8/PPP2PPP/RNBQKB1R w KQkq - 0 5'},
      {label: 'Hyperaccelerated Dragon', value: 'rnbqkbnr/pp1ppp1p/6p1/2p5/4P3/5N2/PPPP1PPP/RNBQKB1R w KQkq - 0 3'},
    ],
    startPosition: 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1',
    playerColor: 'white',
    showStartPositionValidationError: false,
    currentOpeningName: '',
    currentPositionPlayed: 10000000,
    progress: 0,
    event: null,
    moves: [],
    lifes: 3,
  },
  methods: {
    newGame() {
      this.moves = [];
      this.lifes = 3;
      this.currentPositionPlayed = 10000000;
      this.progress = 0;
      this.emit('new');
    },
    emit(event) {
      this.event = {type: event};
    },
    refreshProgress(played) {
      this.currentPositionPlayed = played;
      this.progress = (this.currentPositionPlayed < 10) ? 7 
        : (8 - Math.log(this.currentPositionPlayed) / Math.log(10));
    },
    refreshOpeningName(name) {
      this.currentOpeningName = name;
    },
    addMoveToList(move) {
      this.moves.push(move);
    },
    onWrongMove(move) {
      this.lifes -= 1;
    },
    onMiddlegameReached() {
      alert('Mittelspiel erfolgreich erreicht. GlÃ¼ckwunsch!');
    },
    formatStrength(strength){
      switch(strength){
        case 3: return 'Top';
        case 2: return 'Good';
        case 1: return 'Ok';
        case 0: return 'Bad';
      }
    },
    formatProbability(p) {
      return `${Math.round(100*p)}%`;
    },
    openSettings() {
      this.showSettings = true;
    },
    validateFen() {
      this.showStartPositionValidationError = !this.$refs.chessboard.game.validate_fen(this.settings.startPosition).valid;
    },
    applySettings() {
      this.showSettings = false;
      let newGameNeeded = false;
      if (this.showStartPositionValidationError) {
        this.settings.startPosition = this.startPosition;
      } else if (this.settings.startPosition !== this.startPosition) {
        this.startPosition = this.settings.startPosition;
        newGameNeeded = true;
      }
      if (this.settings.playerColor !== this.playerColor) {
        this.playerColor = this.settings.playerColor;
        newGameNeeded = true;
      }
      if (newGameNeeded) {
        this.newGame();
      }
    }
  },
  created() {
    
  }
});

    </script>
  </body>
</html>